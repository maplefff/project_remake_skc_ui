# 開發階段六：優化與完善 (可選)

**對應主計畫階段:** [階段六：優化與完善 (Refinement & Optimization - Optional)](Development_plan.md#階段六優化與完善-refinement--optimization---optional)

**目標:** 提升應用程式的穩定性、效能和整體使用者體驗。

**注意:** 此階段為可選階段，根據專案時間和需求決定是否執行以及執行哪些任務。

## 詳細任務分解

### 1. 改善錯誤處理與回饋

*   **任務:** 審查現有的錯誤處理機制，提供更友好、更具體的使用者錯誤提示。
*   **步驟:**
    1.  檢查爬蟲過程 (`skcScraper.ts`, `imdbScraper.ts`) 中的 `try...catch` 區塊，確保捕獲了所有預期的錯誤（網路錯誤、解析錯誤、找不到元素等）。
    2.  檢查 IPC 處理函數 (`ipcHandlers.ts`) 中的錯誤處理，確保向渲染行程傳遞了有意義的錯誤信息，而不是僅僅拋出通用錯誤。
    3.  在前端 (`MovieList.vue`, `MovieDetail.vue`)，當接收到來自後端的錯誤時，使用 Element Plus 的 `ElMessage` 或 `ElNotification` 顯示更清晰的錯誤提示給使用者（例如，"無法加載電影列表，請檢查網路連接或稍後重試"，"獲取《電影名稱》的 IMDb 資訊失敗"）。
    4.  考慮為長時間運行的爬蟲任務（特別是首次運行或網路較慢時）提供更明顯的加載指示或進度提示（雖然精確進度可能困難，但可以顯示"正在加載 IMDb 資訊..."）。
*   **驗證:** 模擬不同的錯誤情況（斷網、API 失敗、資料格式錯誤），檢查應用是否能優雅地處理並給出適當提示。

### 2. 效能優化

*   **任務:** 識別並解決潛在的效能瓶頸，特別是與爬蟲任務相關的。
*   **步驟:**
    1.  **異步化爬蟲:** 確認爬蟲函數 (`fetchSkcMovieData`, `fetchImdbDetails`, `fetchAllMovieData`) 都是異步的 (`async/await`)，並且 IPC 調用 (`ipcMain.handle`) 也是異步的，以避免阻塞主行程。
    2.  **(進階) 獨立工作線程:** 對於 CPU 密集型或長時間 I/O 的爬蟲任務，可以考慮將其移至 Electron 的 [Utility Process](https://www.electronjs.org/docs/latest/api/utility-process) 或使用 Node.js 的 [Worker Threads](https://nodejs.org/api/worker_threads.html)。這可以完全避免阻塞主行程，但會增加 IPC 的複雜性。**（根據實際效能表現決定是否需要）**
    3.  **前端渲染效能:**
        *   檢查 Vue 元件中的 `v-for` 循環，確保使用了 `:key`。
        *   對於非常長的列表，可以考慮引入虛擬滾動庫（雖然在這個應用場景下可能不需要）。
        *   優化圖片加載，確保使用了 `ElImage` 的懶加載。
    4.  **Playwright 資源:** 確保 Playwright 瀏覽器實例在使用後被正確關閉 (`browser.close()`)，釋放資源。
*   **驗證:** 使用開發者工具觀察應用啟動時間、資料加載時間、內存和 CPU 使用情況，確保在合理範圍內。UI 交互保持流暢，即使在爬蟲進行中。

### 3. UI/UX 細節調整

*   **任務:** 根據實際使用體驗，微調介面細節，提升易用性和美觀度。
*   **步驟:**
    1.  重新審視介面佈局、間距、字體大小、顏色對比度，確保視覺舒適和資訊層次清晰。
    2.  檢查交互流程，例如電影選擇、滾動體驗，看是否有可以改進的地方。
    3.  考慮添加一些細微的過渡效果或動畫（使用 Vue 的 `<transition>` 或 CSS transitions），使介面變化更平滑（但避免過度使用）。
    4.  確保應用窗口大小調整時，佈局能合理響應（雖然固定雙欄佈局可能限制較大）。
*   **驗證:** 主觀評估和（如果可能）使用者回饋，確認 UI/UX 達到滿意水平。

### 4. 資料持久化 (緩存)

*   **任務:** 實現本地緩存機制，儲存上次成功獲取的電影資料，以加快後續啟動速度並提供離線查看能力。
*   **步驟:**
    1.  **選擇儲存方式:**
        *   **簡單方案:** 使用 Electron 主行程的 `electron-store` 庫將 `CombinedMovie[]` 資料直接存儲為 JSON 文件。
        *   **更結構化方案:** 使用本地數據庫如 `sqlite3`（需要原生依賴）或基於檔案的嵌入式數據庫。對於此應用，`electron-store` 可能足夠。
    2.  **儲存邏輯:** 在 `fetchAllMovieData` 成功獲取並合併資料後，將結果寫入 `electron-store`。可以考慮加入時間戳。
    3.  **加載邏輯:**
        *   應用程式啟動時，或前端請求資料 (`get-combined-movies`) 時，首先嘗試從 `electron-store` 讀取緩存資料。
        *   檢查緩存資料是否存在以及是否過期（例如，定義一個緩存有效期，如 1 小時或當天）。
        *   如果緩存有效，直接返回緩存資料給前端。
        *   如果緩存不存在或已過期，則執行完整的爬蟲流程，獲取新資料，更新緩存，然後返回新資料。
    4.  **前端提示:** 在前端顯示資料時，可以 subtly 地提示資料是來自緩存還是即時獲取的，或者顯示上次更新的時間。提供一個手動刷新的按鈕。
*   **驗證:**
    *   首次啟動時執行爬蟲，關閉再打開後能快速從緩存加載。
    *   緩存過期後能自動觸發刷新。
    *   手動刷新功能有效。
    *   離線狀態下（如果網路斷開）仍能看到上次緩存的資料。
*   **可能挑戰:** 緩存策略的設計（有效期、更新時機）；處理緩存讀寫錯誤；`electron-store` 的使用。

## 階段產出物

*   經過優化的錯誤處理和使用者回饋機制。
*   可能的效能改進（根據實際情況）。
*   經過微調的 UI/UX。
*   可選的本地資料緩存功能。
*   最終完善的應用程式版本。 